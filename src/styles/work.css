```
从输入URL到显示页面，经过了哪些流程
react hook组件和class组件有啥区别  为什么现在的趋势都是hooks组件
react 15升级16为啥像 will_mount的声明周期会被删掉 这么做的原因是啥
浏览器缓存

1.webpack 打包的流程是怎么样的 
2.webpack 的是怎么解决循环依赖的问题
3.webpack是怎么把模块全部找出来的（我说了通过ast）
4.高版本浏览器的特性，低版本不支持需要poilly，原理是啥？babel的poilly和webpack的是一样吗？有什么区别（没怎么答对）
5. 说一下需要打补丁的js的语法？装饰器是怎么实现的？
6.AST是什么，import的AST结构大概是啥样的，你自己玩过ast吗 
7.npm yarn pnpm 了解吗？有啥区别？
8.pnpm的包是通过软连接还是硬链接？软连接和硬链接有啥区别？
9.使用pnpm的话,node_modules里面的.pnpm文件夹里存放的是啥？（我好像答错了 不太记得了 pnpm用的比较少）
10.静态语言如java， 跟js相比，为什么他们需要编译，js不需要？
11.我说了了js的执行原理，接着问,字节码是什么？字节码和二进制码一样吗？
12.你平时都是怎么学习的

1.react的PureComponent 做了什么事？
2.封装组件，传递一个jsx的props，怎么校验合法性, 那我传一个数字6能通过校验吗？
3. Class组件的一些声明周期在Hook组件里面分别是怎么对应的？
4. useEffect和useLayoutEffect有什么区别
5. useCallback和useMemo有什么区别，使用场景是什么？
6. useMemo和React.memo的区别又是啥？
7. useRef的使用场景
8. 两个useEffect，都返回了卸载函数，并且都依赖了一个对象，对象有一个属性，这个属性被修改的时候，这两个useEffect的卸载函数的执行情况是怎么样的
9. 让你实现一个useUnMount的卸载的hooks,你怎么实现


querySelectorAll 和 getElementsByClassName 区别
浏览器绘制的过程,布局计算是哪个阶段
如何跨域传递cookie
什么是跨域
== 和 === 区别
js 类型有哪些
什么是this
怎么实现bind
es6继承和es5区别
什么是函数柯里化
object.definedProperty和proxy区别
writable 和configable区别,什么是否可逆
react fiber架构了解,fiber结点有什么属性
如何判断class组件和函数组件 Component.isReactComponent
如何理解hook
useEffect和useLayoutEffect区别
状态管理用哪个, redux和mobx原理
使用context注意哪些问题
class的setState和hook setState区别
react 有什么局限性(缺点)
react框架本身做了哪些安全操作 (xss)
如何避免csrf攻击(token,cookie同源,crossOrign samesite)
webpack5 更新了什么功能,
如何实现webpack插件
tapable原理
contenthash和chunkhash 区别,
https的过程,
s指的是什么

Promsie实现一下
```



1. 从输入URL到显示页面，经过了哪些流程？

一般来说，从输入URL到显示页面经历了以下流程：

1. DNS 解析：将 URL 中的域名解析成 IP 地址。
2. 建立 TCP 连接：通过三次握手建立客户端与服务器的连接。
3. 发送 HTTP 请求：客户端向服务器发送 HTTP 请求。
4. 服务器处理请求并返回 HTTP 响应：服务器收到客户端的请求后进行处理，并将处理结果封装在 HTTP 响应中返回给客户端。
5. 浏览器解析渲染页面：浏览器接收到服务器返回的 HTTP 响应后，开始解析 HTML 文件，构建 DOM 树、CSSOM 树，并生成渲染树，最终将页面呈现出来。
6. react hook组件和class组件有什么区别？为什么现在的趋势都是hooks组件？

React 中，Hook 是一种让你在函数组件中“钩入” React state 及生命周期等特性的方式。与 Class 组件相比，Hook 组件有以下优势：

1. 更容易理解和编写：Hook 将代码分解成更小、更易于理解的函数，同时让你更容易复用这些函数。
2. 更容易测试：Hook 组件使你能够编写更易于测试的代码，而且测试代码更容易编写。
3. 更容易重用状态逻辑：你可以使用自定义 Hook 将组件中的状态逻辑提取到单独的函数中进行重用。
4. 避免 Class 组件中的 this 问题：在 Class 组件中，你需要手动绑定 this 或使用箭头函数来避免 this 问题，而在 Hook 组件中，没有 this 的问题。

因为 Hook 组件的优点和方便性，所以现在的趋势都是使用 Hook 组件，而不是 Class 组件。

1. React 15 升级 16 为什么像 will_mount 的声明周期会被删掉？这么做的原因是什么？

React 16 中删除了 componentWillMount 声明周期方法。原因是 React 团队在设计新的异步渲染机制时，发现 componentWillMount 会造成一些不可预期的问题。比如，如果在 componentWillMount 中使用 setState 来修改组件的状态，那么这些修改会被视为同步的，从而会导致一些不可预期的结果。

为了解决这个问题，React 团队在 16 版本中引入了新的生命周期方法 getDerivedStateFromProps 和 getSnapshotBeforeUpdate，并将 componentWillReceiveProps、componentWillUpdate 和 componentWillUpdate 三个方法合并为一个新的生命周期方法 componentDidUpdate。这些新的生命周期方法可以更好地支持异步渲染，并且可以避免出现不可预期的问题。



1. webpack 打包的流程是怎么样的？
    答：Webpack 的打包流程大致分为以下几个步骤：解析配置文件，解析入口文件及其依赖，编译模块，输出打包文件。

2. webpack 的是怎么解决循环依赖的问题？
    答：Webpack 通过使用模块标识符来解决循环依赖问题。当一个模块被引用时，Webpack 会先去检查该模块是否已经被加载过，如果已经加载过，则直接返回已加载的模块对象，如果没有加载过，则会将该模块的标识符加入到已加载模块的缓存中，并开始加载该模块的依赖模块，这样可以保证每个模块只被加载一次。

3. webpack 是怎么把模块全部找出来的？
    答：Webpack 通过解析入口文件及其依赖来找出所有需要打包的模块。Webpack 会使用 acorn 或者 babel-parser 将入口文件及其依赖解析成 AST（抽象语法树） ，然后遍历 AST 中的 ImportDeclaration 和 RequireExpression ，找出所有依赖的模块，直到所有的依赖都被找出来。

4. 高版本浏览器的特性，低版本不支持需要 polyfill，原理是啥？babel 的 polyfill 和 webpack 的是一样吗？有什么区别？
    答：高版本浏览器的特性在低版本浏览器中没有实现，需要使用 polyfill 进行填充。Polyfill 的原理是检测当前浏览器是否支持某个特性，如果不支持，则提供一个函数实现该特性，这样在代码中使用该特性时，就可以正常运行了。Babel 的 polyfill 和 Webpack 的 polyfill 是不同的，Babel 的 polyfill 主要是将 ECMAScript 2015+ 的新特性转换成 ES5 代码，而 Webpack 的 polyfill 主要是提供浏览器 API 的兼容实现。

5. 说一下需要打补丁的 JS 的语法？装饰器是怎么实现的？
    答：需要打补丁的 JS 语法一般是指新的 ECMAScript 规范中新增的语法，例如 async/await、Promise 等。这些语法在旧版本的浏览器中不被支持，需要使用 polyfill 或者打补丁来实现。 装饰器是一种语法糖，用于简化代码的编写，它可以修饰类、属性和方法等。装饰器的实现主要依靠 ES2016 规范中的提案，通过对类、属性、方法等进行包装

6. AST是什么，import的AST结构大概是啥样的，你自己玩过ast吗？
    答：AST（Abstract Syntax Tree）是源代码的抽象语法结构的树状表示。通过解析源代码，可以将代码转化为AST，以便于对代码进行分析和转换。 import 语句的AST结构一般包含一个 type 属性，表示节点的类型是 ImportDeclaration，还包含 source 和 specifiers 属性，分别表示导入的模块和导入的内容。我有使用过AST工具，比如Babel和Esprima。

7. npm yarn pnpm 了解吗？有啥区别？
    答：npm、yarn和pnpm都是用来管理Node.js包和依赖的工具。npm是Node.js的默认包管理器，yarn是Facebook开发的一款包管理器，而pnpm是一个类似yarn的第三方包管理器，它通过硬链接来共享本地安装的依赖，避免了大量的重复下载和存储。相比于npm和yarn，pnpm在性能和磁盘空间的利用上更有优势。

8. pnpm的包是通过软连接还是硬链接？软连接和硬链接有啥区别？
    答：pnpm的包是通过硬链接实现的。软链接和硬链接都是用于在文件系统中创建链接的方法，区别在于软链接创建的是一个指向目标文件的指针，而硬链接创建的是一个指向目标文件的新文件名。硬链接只能在同一文件系统中创建，而软链接可以跨越不同的文件系统。由于硬链接创建的是一个新的文件名，因此即使原文件被删除，硬链接仍然存在，而软链接则会失效。

9. 使用pnpm的话,node_modules里面的.pnpm文件夹里存放的是啥？
    答：在使用pnpm管理依赖时，node_modules目录中会生成一个.pnpm文件夹，用于存放与依赖相关的元数据和文件缓存。其中的文件缓存可以避免重复下载和存储相同的依赖包，提高依赖包的安装速度和磁盘空间的利用率。

10. 静态语言如java， 跟js相比，为什么他们需要编译，js不需要？ 

    回答：静态语言如Java需要编译，是因为在编译期间就能检测到代码中的错误，而JS是一种动态语言，其代码在运行时才会被解释器执行，因此不需要编译。

11. 我说了了JS的执行原理，接着问，字节码是什么？字节码和二进制码一样吗？ 

    回答：字节码是一种类似于二进制码的中间形式，其主要作用是为了提高代码的执行效率。在Java中，编译后的代码被转换成字节码，这些字节码可以在JVM上运行。而在JavaScript中，由于它是一种解释性语言，因此并没有字节码的概念。相反，JavaScript的代码会被解释器直接执行。

12. 你平时都是怎么学习的？

     回答：我平时学习的方式比较多样化，包括阅读相关的书籍、文档、博客等，观看相关的视频教程，参加在线课程和研讨会，以及自己动手实践。我也会参与一些社区和论坛，与其他人交流和分享经验，从中获取更多的知识和经验。同时，我也会保持对新技术的关注和研究，以跟上技术的发展和变化。

13. react的PureComponent 做了什么事？

​	回答：React的`PureComponent`是一个优化版本的`Component`，它通过实现`shouldComponentUpdate`方法来浅比较组件的`props`和`state`是否改变，从而避免不必要的重渲染。如果`props`和`state`没有变化，就会阻止渲染。这个优化可以在一些场景下提高组件的性能，但是需要注意，当`props`和`state`的数据结构非常复杂时，浅比较也可能会导致错误。

14. 封装组件，传递一个jsx的props，怎么校验合法性, 那我传一个数字6能通过校验吗？

回答：可以使用`prop-types`库来校验组件传递的`props`是否合法。在组件的`propTypes`属性中，可以定义组件需要接收的`props`的类型和是否必须。如果传入的`props`不符合定义，就会在控制台输出一条警告信息。如果你的组件需要接收一个`JSX`的`props`，可以使用`PropTypes.element`或`PropTypes.node`来定义。传入数字6无法通过这种校验。

15. Class组件的一些声明周期在Hook组件里面分别是怎么对应的？

回答：

- `componentDidMount`：`useEffect`。
- `componentDidUpdate`：`useEffect`。
- `componentWillUnmount`：`useEffect`，需要返回一个清除函数来模拟。
- `shouldComponentUpdate`：使用`React.memo`或自定义的`shouldComponentUpdate`方法。

16. useEffect和useLayoutEffect有什么区别？

回答：`useEffect`和`useLayoutEffect`都是`React`的副作用钩子函数。它们的区别在于执行时机不同，`useEffect`在组件渲染完成后异步执行，而`useLayoutEffect`会在组件渲染完成后同步执行。因此，在使用`useLayoutEffect`时需要注意，可能会阻塞组件的渲染，导致性能问题。一般来说，如果副作用不需要同步更新DOM，那么可以使用`useEffect`；如果需要同步更新DOM，那么可以使用`useLayoutEffect`。

1. useCallback和useMemo有什么区别，使用场景是什么？

答：useCallback和useMemo都可以用来缓存函数或值，以避免在每次渲染时都重新创建。其中，useCallback是用来缓存函数的，而useMemo是用来缓存值的。它们的主要区别在于返回值不同，useCallback返回的是缓存的函数，而useMemo返回的是缓存的值。使用场景是在需要缓存函数或值的场景下，例如将函数传递给子组件或使用计算得出的值。

1. useMemo和React.memo的区别又是啥？

答：useMemo和React.memo都可以用来优化组件性能，避免不必要的渲染。其中，useMemo是用来缓存计算值的，而React.memo是用来缓存组件的渲染结果的。它们的主要区别在于返回值不同，useMemo返回的是缓存的值，而React.memo返回的是缓存的组件。使用场景是在需要缓存计算值或组件的渲染结果的场景下，例如在渲染大量数据或者计算耗时的情况下使用useMemo，而在组件渲染结果不变的情况下使用React.memo。

1. useRef的使用场景

答：useRef主要用来在组件之间共享可变值，也可以用来保存任意可变值。它返回一个对象，该对象的current属性初始值为传入的参数，可以在组件的生命周期内保持不变，而不会引起组件重新渲染。使用场景包括但不限于：保存定时器、保存外部库的实例、获取Dom元素引用等。

1. 两个useEffect，都返回了卸载函数，并且都依赖了一个对象，对象有一个属性，这个属性被修改的时候，这两个useEffect的卸载函数的执行情况是怎么样的

答：如果两个useEffect都依赖了同一个对象，并且都返回了卸载函数，在这个对象的属性被修改时，两个useEffect的卸载函数都会被执行。这是因为每次渲染时，都会创建新的对象，而不是使用原来的对象。因此，当对象的属性被修改时，两个useEffect都会引用到不同的对象，它们的卸载函数都会被执行。



1. 实现一个useUnMount的卸载hooks的思路：

   实现一个useUnMount的卸载hooks的思路可以分为以下步骤：

   1. 使用useState创建一个标志位，用来表示组件是否已卸载，初始值为false。

   2. 使用useEffect监听组件是否已卸载，当组件已卸载时，修改标志位为true。

   3. 使用useEffect监听标志位的变化，当标志位变为true时，执行卸载操作。

      ```react
      import { useEffect, useState } from 'react';
      
      function useUnMount() {
        const [isUnMounted, setIsUnMounted] = useState(false);
      
        useEffect(() => {
          return () => {
            setIsUnMounted(true);
          };
        }, []);
      
        useEffect(() => {
          if (isUnMounted) {
            // 执行卸载操作
          }
        }, [isUnMounted]);
      }
      
      export default useUnMount;
      
      ```

   给的另一个答案：

在useEffect中返回一个函数，该函数用于执行组件的清理逻辑，这个函数会在组件卸载时自动执行，从而达到卸载效果。以下是代码示例：

```react
import { useEffect } from 'react';

const useUnMount = (callback) => {
  useEffect(() => {
    return () => {
      if (typeof callback === 'function') {
        callback();
      }
    };
  }, []);
};

export default useUnMount;

```

你可以在需要卸载的组件中使用该自定义hooks，如下所示：

```react
import React, { useState } from 'react';
import useUnMount from './useUnMount';

const MyComponent = () => {
  const [state, setState] = useState(true);

  useUnMount(() => {
    console.log('Component unmounted!');
  });

  const handleClick = () => {
    setState(false);
  };

  return (
    <div>
      {state ? <p>Component mounted!</p> : null}
      <button onClick={handleClick}>Unmount</button>
    </div>
  );
};

export default MyComponent;

```

在上面的例子中，当用户点击“Unmount”按钮时，组件会被卸载，同时会在控制台上输出“Component unmounted!”。

1. querySelectorAll和getElementsByClassName的区别：

querySelectorAll和getElementsByClassName都可以用于获取DOM元素集合，但它们之间有以下几个区别：

- 返回结果类型不同：querySelectorAll返回的是NodeList类型，而getElementsByClassName返回的是HTMLCollection类型。
- 使用方式不同：querySelectorAll可以接受任意CSS选择器，而getElementsByClassName只能接受一个class名称。
- 遍历方式不同：NodeList是一个静态集合，会在返回时就生成一个固定的DOM元素列表，而HTMLCollection是一个动态集合，会在访问时实时遍历DOM树来获取符合条件的元素。

1. 浏览器绘制的过程中，布局计算是哪个阶段？

浏览器绘制的过程可以分为以下几个阶段：处理HTML、处理CSS、布局计算、绘制和合成。布局计算是指根据DOM元素的位置和大小，计算出它们在浏览器中实际的位置和大小。这个过程需要考虑多个因素，包括盒子模型、定位、浮动等。在布局计算的过程中，浏览器会生成一个布局树（Layout Tree），它是DOM树的一个副本，但是只包含需要显示的元素。浏览器会根据这个布局树计算出每个元素的位置和大小，并在屏幕上渲染出相应的图像。

1. 如何跨域传递cookie？ 答：在跨域传递cookie时，需要设置XMLHttpRequest对象的withCredentials属性为true，同时在服务端也需要进行配置，允许接收跨域请求并且允许携带cookie。对于非ajax请求，可以使用JSONP方式实现跨域传递cookie。
2. 什么是跨域？ 答：跨域是指浏览器在向同源服务器发送请求时，限制了与其他源服务器之间的交互。当协议、域名或者端口号中任何一个不同，都被认为是跨域。
3. == 和 === 的区别？ 答：== 用于比较两个值是否相等，如果类型不同会进行类型转换再比较；=== 用于比较两个值是否相等，类型也要相同，不会进行类型转换。
4. JS类型有哪些？ 答：JS类型包括原始类型和引用类型。原始类型有：undefined、null、boolean、number、string、symbol，引用类型有：对象（Object）、数组（Array）、函数（Function）等。
5. 什么是this？ 答：this是指向当前函数执行环境的一个指针，在函数被调用时绑定。在全局作用域中，this指向全局对象（浏览器中是window对象），在对象方法中，this指向调用该方法的对象，在构造函数中，this指向创建的实例对象。在箭头函数中，this指向其声明时所在的作用域中的this，不会被动态改变。

1. 怎么实现bind？

答：可以使用 Function.prototype.bind() 方法来创建一个新的函数，并将其绑定到指定的对象。该方法返回一个新函数，其 this 值被绑定到指定的对象，同时传入的参数也会被绑定。具体实现可以通过 apply 或 call 方法来调用原函数，同时修改 this 的指向。

1. es6继承和es5区别？

答：ES6 引入了 class 语法，使得面向对象编程更加直观和易用。ES6 的继承采用了更加简洁明了的 extends 关键字，同时还可以使用 super 关键字调用父类的构造函数和方法。ES5 中的继承则是通过原型链实现的，需要手动设置子类的原型为父类的实例，且没有直接的方法可以调用父类的构造函数和方法。

1. 什么是函数柯里化？

答：函数柯里化是一种将接受多个参数的函数转化为接受单一参数的函数序列的技术。通过柯里化，我们可以将一个多参数函数转化为一系列只有一个参数的函数。这样的好处是可以将函数的复用性和可读性大大提高，同时还可以简化代码实现。比如，一个接受两个参数的函数可以通过柯里化转化为两个接受一个参数的函数。

1. object.definedProperty和proxy区别？

答：Object.defineProperty() 和 Proxy 都是 JavaScript 提供的用于操作对象属性的工具。它们的主要区别在于，Object.defineProperty() 只能监听对象属性的读写操作，而 Proxy 可以监听对象属性的任何操作，包括读取、设置、删除等。此外，使用 Proxy 还可以对整个对象进行监听，而 Object.defineProperty() 只能对单个属性进行监听。

1. writable 和configable 区别,什么是否可逆？

答：writable 和 configurable 是 Object.defineProperty() 方法中用于设置对象属性特性的选项。writable 用于控制对象属性是否可写，configurable 用于控制对象属性是否可配置。如果一个属性被设置为不可写，则该属性的值不能被修改；如果一个属性被设置为不可配置，则该属性的描述符不能被修改。这些特性可以通过重新定义对象属性来修改，但是如果在对象的原型上定义了相同名称的属性，则不可逆。

1. React Fiber架构了解，Fiber节点有什么属性？

React Fiber是React v16中新的reconciliation算法，主要用于解决React中长时间执行JS代码导致页面卡顿的问题。它通过将reconciliation算法分割为多个阶段执行，并允许在不同阶段中间插入其他任务，使得React的reconciliation过程变得可中断、可恢复。

Fiber节点是React Fiber中的一个概念，每个Fiber节点表示一个组件的实例或一个DOM节点。每个Fiber节点都有一些属性，包括：

- type：组件的类型，可以是函数组件、类组件、原生DOM节点等。
- key：组件的唯一标识，用于在列表中识别组件。
- ref：用于引用组件的实例或DOM节点。
- return：当前节点的父节点。
- child：第一个子节点。
- sibling：兄弟节点。
- memoizedState：组件的状态。
- memoizedProps：组件的属性。
- effectTag：表示组件在当前阶段需要执行的任务类型。
- nextEffect：表示在当前阶段中下一个需要执行的任务。
- alternate：用于在协调阶段保存上一个Fiber节点的状态，用于实现Fiber树的回溯和恢复。

1. 如何判断Class组件和函数组件？

我们可以使用 `Component.isReactComponent` 属性来判断一个组件是否为Class组件。

对于函数组件，它没有 `isReactComponent` 属性，而且它的类型是一个函数。因此，我们可以通过判断组件的类型是否为函数，来判断一个组件是否为函数组件。

1. 如何理解Hook？

Hook是React v16.8中引入的新特性，它可以让我们在函数组件中使用状态、副作用等特性。通过Hook，我们可以在不使用Class组件的情况下，实现和Class组件相同的功能。

在函数组件中使用Hook，需要使用React提供的一些Hook函数，比如useState、useEffect等。这些Hook函数可以让我们在函数组件中使用状态、订阅副作用等特性。

1. useEffect和useLayoutEffect的区别是什么？

useEffect和useLayoutEffect都是React提供的Hook函数，用于处理副作用。它们的区别在于执行的时机。

useEffect的执行时机是浏览器渲染完页面后，即组件已经被挂载到DOM上后执行的，所以它的副作用是异步执行的，不会阻塞浏览器渲染。而useLayoutEffect的执行时机是在浏览器渲染之前，即组件挂载到DOM之前执行的，所以它的副作用是同步执行的，会阻塞浏览器渲染。

1. 状态管理用哪个, redux和mobx原理

Redux和MobX都是常用的状态管理库。Redux是一个基于单一状态树的状态管理库，它的核心思想是通过action和reducer来改变应用的状态。MobX则是基于响应式编程的状态管理库，通过观察者模式来监听数据变化。Redux需要手动编写reducer和action，使用起来比较繁琐，但是更加明确，容易调试和维护。MobX则使用起来更加简洁，但是可能会影响代码的可维护性。

1. 使用context注意哪些问题

Context是React中的一个API，用于跨层级传递数据。在使用时，需要注意以下几个问题：

- 避免过度使用Context，因为它会增加组件之间的耦合性。
- Context的更新可能会导致所有消费者重新渲染，需要注意性能问题。
- 在使用Context时，需要注意对数据进行合理的控制和管理，避免出现数据异常的情况。

1. class的setState和hook setState区别

class组件的setState和useState的setState都是用于更新组件状态的方法，区别在于class组件的setState方法是异步执行的，而useState的setState方法是同步执行的。因为class组件的setState方法是异步执行的，所以在执行多次setState时，可能会出现不符合预期的情况。而useState的setState方法是同步执行的，所以不会出现这种问题。此外，class组件的setState方法也支持传入一个回调函数，在状态更新后执行。

1. react 有什么局限性(缺点)

尽管 React 是一个非常流行的前端框架，但是它也有一些局限性和缺点。其中一些包括：

- 学习成本较高：React 有很多概念和特性，对于初学者来说可能需要一些时间和努力才能理解。
- 基础库相对较大：React 的基础库相对较大，需要下载和加载，可能会影响应用的性能。
- 只是一个视图层框架：React 只负责视图层，没有提供完整的框架解决方案。
- 复杂的状态管理：在大型应用中，React 的状态管理可能变得非常复杂。
- 可能出现代码冗余：由于 React 是组件化的，因此可能出现组件重复或代码冗余的问题。

1. react框架本身做了哪些安全操作 (xss)

React 框架本身并没有提供针对 XSS 攻击的专门安全防范措施，但它可以通过一些安全编程实践来预防和缓解 XSS 攻击。例如：

- 将用户输入和动态内容进行编码：在渲染用户输入和动态内容之前，应该将它们进行编码，以防止恶意脚本注入。
- 防止直接操作 DOM：使用 React 的虚拟 DOM，避免直接操作原生 DOM，以减少 XSS 攻击的风险。
- 使用官方提供的组件：React 提供了一些官方组件，例如 `<a>` 和 `<img>`，它们已经实现了一些安全措施，比如自动过滤危险的属性。

=============回答2

React框架本身并没有直接处理安全操作，但它提供了一些安全机制来避免常见的安全问题，例如：

1. 防止XSS攻击：React使用JSX语法来防止XSS攻击。JSX可以防止注入攻击，因为它会将用户输入转义为字符串。
2. 防止注入攻击：React推荐使用受控组件，它将表单数据绑定到state，而不是使用非受控组件来处理表单输入。
3. 避免在组件渲染中插入危险的HTML：React提供了一个名为dangerouslySetInnerHTML的方法，它允许直接插入HTML代码。但是，由于它是“危险”的，因此必须小心使用。
4. 避免在组件渲染中插入危险的脚本：React通过提供内联事件处理程序来避免将脚本注入到组件中。
5. 使用key属性避免重复渲染：React使用key属性来帮助识别渲染的组件，以避免出现重复渲染的问题。

需要注意的是，虽然React提供了这些安全机制，但这并不意味着使用React就能够完全避免安全问题。在编写React应用程序时，我们还需要采取其他安全措施来保护应用程序免受各种安全威胁。

1. 如何避免csrf攻击(token,cookie同源,crossOrign samesite)

CSRF（Cross-Site Request Forgery）攻击是一种通过伪造用户身份进行恶意操作的攻击方式。为了避免 CSRF 攻击，可以采取以下措施：

- 使用 CSRF Token：在每个请求中包含一个随机生成的 Token，服务器可以验证 Token 的合法性，从而避免 CSRF 攻击。
- 同源限制：使用同源限制，即确保请求的源站与服务器的源站相同，以避免攻击者冒充用户发起请求。
- 设置 Cookie 的 SameSite 属性：使用 SameSite 属性可以限制 Cookie 只在同源请求中发送，从而防止跨站点请求伪造攻击。
- Cross-Origin Resource Sharing（CORS）：通过设置 CORS 响应头，可以控制浏览器是否允许跨域请求。

1. webpack5 更新了什么功能?

- webpack5增加了许多新的特性和优化，例如:
  - 使用持久化缓存以加速构建
  - 通过提高输出质量和构建时间来提高构建性能
  - 优化Tree shaking，以减少构建输出的大小
  - 支持顶级 await
  - 提供了多个开箱即用的优化功能，如代码拆分和按需加载等等。

1. 如何实现webpack插件?

- 实现一个webpack插件需要编写一个符合webpack插件规范的JavaScript类，并在其中实现一个apply方法。
- apply方法接收一个webpack Compiler实例作为参数，可以使用该实例的钩子函数来在不同的构建阶段中执行自定义操作。
- 可以在Webpack插件市场中查找已有的插件，或者自己编写符合规范的插件来满足特定的需求。

1. tapable原理?

- tapable是Webpack使用的事件发布/订阅库，用于在Webpack内部管理插件的注册和调用。
- 事件发布/订阅的基本原理是，先定义一组事件，然后在代码中通过订阅事件来注册相应的回调函数，在事件触发时执行已注册的回调函数。
- 在Webpack中，tapable提供了一组钩子函数，可以在Webpack的不同阶段中注册回调函数，这些回调函数可以用于实现自定义的构建逻辑或处理Webpack输出结果。
- tapable提供了多种钩子函数，如SyncHook、SyncBailHook、AsyncSeriesHook等等，不同的钩子函数有不同的执行方式和返回值，可以根据需求来选择合适的钩子函数。

1. contenthash和chunkhash区别?

- contenthash是根据文件内容生成的hash值，如果文件内容发生了改变，hash值也会发生改变，用于保证静态资源的缓存效果。
- chunkhash是根据chunk生成的hash值，chunk是Webpack中对代码块的概念，它包含了一组模块，是Webpack进行模块化打包的基本单位。
- 当一个chunk包含的模块发生改变时，chunkhash也会发生改变，用于保证代码的版本控制和缓存更新。
- 因此，contenthash一般用于处理静态资源，chunkhash用于处理代码块，两者的使用场景不同。

1. https的过程，s指的是什么？

​	HTTPS (Hypertext Transfer Protocol Secure) 是一种基于传输层安全协议 TLS/SSL 的 HTTP 协议。它通过使用 SSL/TLS 加密来保护通信的安全。HTTPS 的过程主要分为以下几个步骤：

1. 客户端向服务器发起 HTTPS 请求，请求中包含支持的加密算法和随机数等信息。
2. 服务器向客户端返回自己的 SSL 证书，包含公钥和证书信息。
3. 客户端对服务器返回的证书进行验证，如果验证通过，生成一个随机的加密密钥。
4. 客户端使用服务器返回的公钥对生成的密钥进行加密，然后发送给服务器。
5. 服务器使用自己的私钥对加密后的密钥进行解密。
6. 客户端和服务器使用这个密钥对整个会话过程中传输的数据进行加密和解密。

在 HTTPS 通信过程中，s 指的是 SSL (Secure Sockets Layer) 或 TLS (Transport Layer Security) 协议。这两种协议都是为了解决网络数据传输的安全问题而设计的，SSL 是较早的一种加密通信协议，TLS 是 SSL 的后继者，因为 SSL 存在一些安全漏洞，已经被 TLS 取代。

1. 用js实现Promise

Promise是一种异步编程的解决方案，可以用于处理异步操作的结果和错误。以下是使用原生JavaScript实现一个简单的Promise：

```javascript
function Promise(fn) {
  var self = this;
  self.value = null;
  self.error = null;
  self.onFulfilled = null;
  self.onRejected = null;

  function resolve(value) {
    setTimeout(function() {
      self.value = value;
      self.onFulfilled(self.value);
    }, 0);
  }

  function reject(error) {
    setTimeout(function() {
      self.error = error;
      self.onRejected(self.error);
    }, 0);
  }

  fn(resolve, reject);
}

Promise.prototype.then = function(onFulfilled, onRejected) {
  this.onFulfilled = onFulfilled;
  this.onRejected = onRejected;
}

Promise.prototype.catch = function(onRejected) {
  this.onRejected = onRejected;
}

```

以上代码实现了一个基本的Promise，其中resolve函数和reject函数用于处理异步操作的结果和错误，then函数和catch函数分别用于设置回调函数，可通过then函数来获取异步操作的结果，可通过catch函数来捕获异步操作的错误。